Yêu cầu kỹ thuật:
- Framework: React + TypeScript
- Build tool: Vite
- Chỉ viết FRONTEND, không viết backend
- Cho phép sử dụng MOCK DATA ĐƠN GIẢN để demo UI
- Mock data chỉ ở mức:
  - User A
  - Địa điểm 1, 2
  - Nội dung mẫu 1
- Khi có API thì ưu tiên gọi API, nếu chưa có API thì fallback sang mock data
- Không hardcode logic backend
- UI đơn giản, dễ hiểu, phục vụ đồ án
- Styling đơn giản (CSS thường hoặc Tailwind đều được)

--------------------------------
- Tách component rõ ràng
- Dùng React Router
- Dùng hook (useState, useEffect)
- Mock data để trong file riêng (mock.ts)
- Có thể dễ dàng thay mock bằng API thật
- Code dễ đọc, có comment giải thích

Không cần UI quá đẹp, ưu tiên rõ ràng chức năng và dễ hiểu luồng sử dụng.

# CÁC BẢNG 

user.csv: user_id,user_name,full_name,avatar_url
place.csv: place_id,place_name,address,thumb_url,description,content
user_place.csv: user_id,place_id
comment.csv: id,username,place_id,content,date,rating

# CÁC CHỨC NĂNG
gọi api tới localhost: cổng 5000

1. Người dùng bình thường:
    - Khi đăng nhập: hiện thị thông tin, các địa điểm đã đi (chỉ cần nhập tên)
    - Khi vào khám phám: hiện thị danh sách địa điểm chưa đi
        + Có khung tìm kiếm theo tên
        + Có khung tìm kiếm nhờ ai:
            a. Nếu không nhập gì hết: thì làm theo user_id (làm cách nào đó khi đăng nhập thì lưu lại user_id, để trên thanh tìm kiếm cx dc)
            b. Nếu nhập: thì làm theo content-based
            (nói chung 2 cái này cùng gọi vào 1 cái api, chỉ cần làm cách nào để phân biệt là được)
    
2. Người dùng là Admin:
    không có 2 trang của người dùng
    2 chức năng dưới là 2 trang khác nhau
    - nhập tên người dùng:
        + xuất hiện thông kê của người đó (đã đi bao nhiêu cái)
        + hiện những comment của người đó (nội dùng và tên địa điểm)
    - nhập tên địa điểm:
        + khi nhập tên
            + hiện các comment 
            + hiện chỉ số đánh giá
        + khi không nhập
            + danh sách địa điểm, với thông số đánh giá



# ĐÂY LÀ FILE types.ts
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true
  }
}

# ĐÂY LÀ CÁC API

import { User, Place, Comment, RecommendationRequest } from '../types';
import * as MOCK from '../mock';

const BASE_URL = 'http://localhost:5000';

// Helper function to handle fetch with fallback
async function fetchWithFallback<T,>(url: string, fallback: T): Promise<T> {
  try {
    const response = await fetch(`${BASE_URL}${url}`);
    if (!response.ok) throw new Error('API request failed');
    return await response.json();
  } catch (error) {
    console.warn(`Falling back to mock data for: ${url}`, error);
    return fallback;
  }
}

export const apiService = {
  // Authentication mock logic
  async login(username: string): Promise<User | null> {
    const users = await fetchWithFallback('/users', MOCK.MOCK_USERS);
    return users.find(u => u.user_name === username) || null;
  },

  async getPlaces(): Promise<Place[]> {
    return fetchWithFallback('/places', MOCK.MOCK_PLACES);
  },

  async getVisitedPlaces(userId: string): Promise<string[]> {
    const userPlaces = await fetchWithFallback(`/user_place?user_id=${userId}`, 
      MOCK.MOCK_USER_PLACES.filter(up => up.user_id === userId)
    );
    return userPlaces.map(up => up.place_id);
  },

  async getRecommendations(req: RecommendationRequest): Promise<Place[]> {
    // Both content-based and ID-based go to same endpoint
    const queryParams = new URLSearchParams({
      user_id: req.user_id,
      ...(req.query ? { query: req.query } : {})
    });
    
    try {
      const response = await fetch(`${BASE_URL}/recommendations?${queryParams.toString()}`);
      if (!response.ok) throw new Error();
      return await response.json();
    } catch {
      // Logic mock: nến không có query thì trả về danh sách chưa đi
      const all = MOCK.MOCK_PLACES;
      const visitedIds = MOCK.MOCK_USER_PLACES.filter(up => up.user_id === req.user_id).map(up => up.place_id);
      return all.filter(p => !visitedIds.includes(p.place_id));
    }
  },

  async getCommentsByPlace(placeId: string): Promise<Comment[]> {
    return fetchWithFallback(`/comments?place_id=${placeId}`, 
      MOCK.MOCK_COMMENTS.filter(c => c.place_id === placeId)
    );
  },

  async getCommentsByUser(username: string): Promise<Comment[]> {
    return fetchWithFallback(`/comments?username=${username}`, 
      MOCK.MOCK_COMMENTS.filter(c => c.username === username)
    );
  },

  async getAllComments(): Promise<Comment[]> {
    return fetchWithFallback('/comments', MOCK.MOCK_COMMENTS);
  },

  // Added helper to calculate ratings mapping
  async getPlaceRatings(): Promise<Record<string, { avg: string; count: number }>> {
    const comments = await this.getAllComments();
    const ratings: Record<string, { total: number; count: number }> = {};
    
    comments.forEach(c => {
      if (!ratings[c.place_id]) {
        ratings[c.place_id] = { total: 0, count: 0 };
      }
      ratings[c.place_id].total += c.rating;
      ratings[c.place_id].count += 1;
    });

    const result: Record<string, { avg: string; count: number }> = {};
    Object.keys(ratings).forEach(id => {
      result[id] = {
        avg: (ratings[id].total / ratings[id].count).toFixed(1),
        count: ratings[id].count
      };
    });
    return result;
  }
};